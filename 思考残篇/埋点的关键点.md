# 埋点的关键点

标签: #埋点; #数据科学; #自己的思考

## 埋点内容

### I. 时间

#### 1. 时间点(A时间)

时间点是指埋点发送的时间点，这个是一般意义上的埋点时间，但是要注意的问题是，使用何种时间比较精确：

* 客户端时间：用户可能篡改
* 服务器接收时间：接收延迟
* 数据处理完的时间：计算复杂带来的延迟

理论上在表中三个时间都要带上，一定程度上可以监控服务稳定性，还有校准客户端时间的作用

#### 2. 时态时间(B时间)

时态时间不看重具体的时间点，它看重的事件发生的先后。在此可能关注的是我们几个埋点事件发生的先后。这类时间往往有两个方案得到：

1. 直接在服务端开窗排序。好处是免去的埋点和埋点测试，缺点是如果涉及多表时计算非常复杂，要求数仓的性能和算力较好。
2. 在埋点时埋入前一个行为的标识或ID。好处是可以很快地理顺整个事件发生流，缺点是前端埋点相当繁琐。且有很多维度讨论「前一个行为」是什么，比如有时候关注的是前一个发生曝光的是哪个页面，或者直接是上一个点击的商品是什么。
3. 采用自增的发送编号。最好是以Session为单位，每一个发送的埋点都发送一个次序的编号。这么做事实上就是将开窗算力的负担前移到客户端中了

#### 3. 时间间隔

有时候我们会需要获取一个事件发生的时间间隔甚至是整个应用的使用时长。这个就是时间间隔的含义。大致上有以下几种方案，获取到时间间隔：

* 直接使用两个埋点的时间差做加减。比如我们要获得一个用户访问Session的时长，最方便的方法就是埋一个Session的Unique ID，通过每个Session的最迟的时间点减去最早的时间点即可。但是这个需要建立在埋点足够多的前提下，这个时间才会准确，如果埋的最后的事件离真实退出点很远，就会造成相当大的误差。
* 使用延迟埋点的方式。就是知道某个事件彻底结束，才发出请求，此时在这个点埋入持续的时间。缺点参考下面的**事件延迟**。
* 在下一个事件中埋上一个事件的持续时间。这个是不错的操作，最好对事件类型ID有详细的编码，并在Session中埋入自增的发送编号。

### 位置

#### 1. 地点

在有权限的前提下，埋入地点信息会提供大量用户资讯。常用的获取地点的数据包括：

* 直接的经纬度数据：往往需要授权
* IP数据：不需要授权，但是可能会有代理等问题
* 用户信息数据：包括身份证号、银行账号、电话号码。这些都有地理信息

#### 2. 事件位置

这里事件位置是指事件发生在应用中的位置，这些位置包括以下内容。

* 

## 基本问题

* 业务接口性能
* 算力
* 存储
* 安全

## 常见模式

### I. 延迟发送

#### 1. 同步发送

**描述**：在事件触发时就发送埋点。

**场景**：曝光时发送曝光埋点，点击时发送点击埋点

**优点**：

* 埋点逻辑简单
* 时间校准容易

**问题**：

* 一些事件需要通过关联的方式才能计算，增加服务端算力
  * 例子：曝光和点击，判断是否未点击需要关联两种数据

#### 2. 事件延迟

**描述**：一些有关联的事件，待事件触发后在发送。

**场景**：曝光后并不发送曝光埋点，待是否点击的判断点发生后再将点击相关数据放置到曝光埋点中发送。

**优点**：

* 事实上讲算力放置前端，减少服务端算力

**缺点**：

* 存在丢数据的可能
  * 例子：在发送前，用户提前关闭页面或APP
* 判断事件完成的时机比较难
  * 例子：如果是基于时间判断是否点击，无法确定标准的时间点
* 如果事件是一对多的，会让埋点过于复杂
  * 例子：一个曝光可能有多个点击行为
  * 例子：曝光、点击后还有确认等一系列行为

#### 3. 批量发送

**描述**：数据以批的方式到数目后发送；或者判断空闲时发送

**场景**：一个用户每执行10个行为，进行一次发送

**优点**：

* 整个服务器不稳定或者规模较小的情况
* 服务器端需要进行大量运算写入事务型数据库的情况

**缺点**：

* 存在整批数据丢失的可能
  * 例子：用户清空缓存等
* 对实时需求高的业务可能无法实现
  * 例子：推荐系统

#### 4. 定时间隔埋点

**描述**: 每隔一段时间发送一个埋点

**场景**: 再无法获取结束时间，如停留时间时间时采用间隔发送来获取停留时间

**优点**:

* 计算简单
* 解决浏览器关闭问题

**缺点**:

* 埋点累赘，实际上一个点位发送了很多次。

### II. 处理模式

#### 1. 客户端处理

**描述**: 一些数据的运算放置客户端处理

**场景**: 在埋点中带入留存天数，免于服务端关联计算

**优点**:

* 减少服务端的压力

**缺点**:

* 有缓存问题
* 影响客户端性能

#### 2. 服务端同步处理

**描述**: 服务端接受请求后，处理好写入数据库

**场景**: 传统记录日志的方式

**优点**:

* 数据库干净
* 业务后端可以兼任完成任务，无需单独的数据部门处理

**缺点**:

* 存在影响服务端性能的问题
* 由于上述问题导致的只能执行的任务相对简单

#### 3. 服务端异步处理

**描述**: 服务端仅返回成功，就将数据丢入ES中；或者通过日志进入Kafka中

**优点**:

* 数据是异步处理的，不会影响到业务
* 可以进行更加复杂的基于数仓的计算

**缺点**:

* 由于异步处理，导致数据反馈有延时
* 日志采集系统复杂，不方便初创公司使用

### III. 同构与异构埋点

#### 1. 同构埋点

**描述**: 所有埋点走一个接口

**优点**:

* 数据格式统一
* 实时数据可以防止在一个表中方便检索和查询
* 增加新点位时不影响大体上的处理结构

**缺点**:

* 每类行为的埋点可能略有差异，无法通过相同的参数表述
* 如果要分表储存不同行为数据，需要更多算力
* 无法在源头处分散消费节点

**解决方案**:

* 使用`JSon`字段描述非公共的埋点项目

#### 2. 异构埋点

**描述**：不同行为走不同接口

**优点**:

* 方便基于不同埋点写不同的处理
* 方便分表储存

**缺点**:

* 增加新点位时需要增加新的处理流
* 数据格式因为工作问题等到最后无法统一，造成维护上的歧义和难度
* 一些实时数据批量查询的可能需要跨表查询

## 一些注意点

### 1. 用户时间校准

### 2. 数据可用性校验